import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { Order, NotificationProps } from '../types';
import { queryClient } from '../lib/queryClient';

interface SocketContextProps extends NotificationProps {
  children: ReactNode;
}

interface SocketContextValue {
  connected: boolean;
  reconnect: () => void;
}

const SocketContext = createContext<SocketContextValue | undefined>(undefined);

export const useSocket = () => {
  const context = useContext(SocketContext);
  if (!context) {
    throw new Error('useSocket must be used within a SocketProvider');
  }
  return context;
};

// Cr√©er un √©v√©nement personnalis√© pour les notifications de stock
const createStockNotificationEvent = (notification: any) => {
  return new CustomEvent('stock:notification', { detail: notification });
};

export const SocketProvider: React.FC<SocketContextProps> = ({ children, showNotification }) => {
  const [socket, setSocket] = useState<WebSocket | null>(null);
  const [connected, setConnected] = useState(false);

  const setupSocket = () => {
    // Utiliser le protocole ws:// ou wss:// selon le protocole actuel (http ou https)
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const host = window.location.host;
    const wsUrl = `${protocol}//${host}/ws`;
    
    const newSocket = new WebSocket(wsUrl);

    newSocket.onopen = () => {
      console.log('WebSocket connected');
      setConnected(true);
      showNotification('Connexion au serveur √©tablie', 'success');
      
      // S'abonner aux notifications importantes
      const subscriptions = ['all', 'critical', 'high', 'stock'];
      subscriptions.forEach(channel => {
        newSocket.send(JSON.stringify({
          type: 'subscribe',
          channel
        }));
      });
    };

    newSocket.onclose = () => {
      console.log('WebSocket disconnected');
      setConnected(false);
      showNotification('Connexion au serveur perdue', 'error');
    };

    newSocket.onerror = (error) => {
      console.error('WebSocket connection error:', error);
      setConnected(false);
    };

    newSocket.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        console.log('Message WebSocket re√ßu:', data.type);
        
        // G√©rer les diff√©rents types de messages
        switch (data.type) {
          case 'notification':
            // Traitement prioritaire des notifications
            setTimeout(() => {
              handleNotification(data.data);
              // Forcer le rafra√Æchissement des donn√©es de notification
              queryClient.invalidateQueries(['notifications', 'recent'], { 
                refetchType: 'active',
                refetchActive: true,
                refetchInactive: false
              });
              queryClient.invalidateQueries(['notifications', 'unread-count'], { 
                refetchType: 'active',
                refetchActive: true,
                refetchInactive: false
              });
            }, 0);
            break;
          case 'stock:notification':
            // Traitement prioritaire des notifications de stock
            setTimeout(() => {
              handleStockNotification(data.data);
            }, 0);
            break;
          case 'order:new':
            // Traitement prioritaire des nouvelles commandes
            setTimeout(() => {
              handleNewOrder(data.data);
            }, 0);
            break;
          case 'order:updated':
            handleOrderUpdated(data.data);
            break;
          case 'order:status':
            handleOrderStatus(data.data);
            break;
          case 'recent_notifications':
            // Mise √† jour imm√©diate du cache des notifications r√©centes
            queryClient.setQueryData(['notifications', 'recent'], data.data);
            break;
          case 'notification:all-read':
            // D√©clencher un √©v√©nement pour informer les composants que toutes les notifications ont √©t√© supprim√©es
            window.dispatchEvent(new CustomEvent('notification:all-read'));
            // Invalider les requ√™tes li√©es aux notifications pour forcer un rechargement
            queryClient.invalidateQueries(['notifications', 'history']);
            queryClient.invalidateQueries(['notifications', 'recent']);
            queryClient.invalidateQueries(['notifications', 'unread-count']);
            break;
          default:
            console.log('Message re√ßu:', data);
        }
      } catch (error) {
        console.error('Erreur lors du traitement du message WebSocket:', error);
      }
    };

    setSocket(newSocket);

    return newSocket;
  };

  // Gestionnaires d'√©v√©nements
  const handleNotification = (data: any) => {
    showNotification(data.message, data.severity.toLowerCase());
  };
  
  // Nouveau gestionnaire sp√©cifique pour les notifications de stock
  const handleStockNotification = (notification: any) => {
    console.log('Notification de stock re√ßue:', notification);
    
    // Mettre √† jour imm√©diatement le cache des notifications r√©centes
    // Cette approche est plus rapide que d'attendre une requ√™te r√©seau
    try {
      const currentNotifications = queryClient.getQueryData(['notifications', 'recent']) || [];
      queryClient.setQueryData(['notifications', 'recent'], [notification, ...currentNotifications]);
      
      // Incr√©menter le compteur de notifications non lues
      const currentCount = queryClient.getQueryData(['notifications', 'unread-count']) || 0;
      queryClient.setQueryData(['notifications', 'unread-count'], currentCount + 1);
    } catch (error) {
      console.error('Erreur lors de la mise √† jour du cache des notifications:', error);
    }
    
    // Afficher la notification visuelle √† l'utilisateur
    showNotification(
      notification.message,
      getSeverityType(notification.severity)
    );
    
    // D√©clencher un √©v√©nement personnalis√© pour que les composants puissent r√©agir imm√©diatement
    window.dispatchEvent(createStockNotificationEvent(notification));
    
    // Invalider les requ√™tes li√©es aux notifications avec une priorit√© √©lev√©e
    queryClient.invalidateQueries(['notifications', 'recent'], { 
      refetchType: 'active',
      refetchActive: true,
      refetchInactive: true
    });
    queryClient.invalidateQueries(['notifications', 'unread-count'], { 
      refetchType: 'active',
      refetchActive: true,
      refetchInactive: true
    });
    
    // Invalider √©galement les requ√™tes li√©es aux produits et commandes si la notification est critique
    if (notification.severity === 'CRITICAL' || notification.severity === 'HIGH') {
      queryClient.invalidateQueries(['products'], {
        refetchType: 'active',
        refetchActive: true
      });
      queryClient.invalidateQueries(['orders'], {
        refetchType: 'active',
        refetchActive: true
      });
      
      // Si la notification contient un ID de produit, invalider sp√©cifiquement ce produit
      if (notification.productId) {
        queryClient.invalidateQueries(['products', notification.productId], {
          refetchType: 'active',
          refetchActive: true
        });
      }
      
      // Si la notification contient un ID de commande, invalider sp√©cifiquement cette commande
      if (notification.orderId) {
        queryClient.invalidateQueries(['orders', 'detail', notification.orderId], {
          refetchType: 'active',
          refetchActive: true
        });
      }
    }
  };

  const handleNewOrder = (order: Order) => {
    console.log('Nouvelle commande re√ßue via WebSocket:', order);
    
    // V√©rifier que l'ordre contient un num√©ro de commande
    const orderNumber = order.orderNumber || order.id?.substring(0, 8).toUpperCase() || 'UNKNOWN';
    
    // Afficher une notification plus d√©taill√©e
    showNotification(
      `Nouvelle commande re√ßue: #${orderNumber} - ${order.items || 'N/A'} article(s) - ${order.totalAmount?.toFixed(2) || 'N/A'} ‚Ç¨`, 
      'info'
    );
    
    // Invalider les requ√™tes pour forcer un rechargement imm√©diat des donn√©es
    queryClient.invalidateQueries(['orders'], {
      refetchType: 'active',
      refetchActive: true,
      refetchInactive: true
    });
    queryClient.invalidateQueries(['orders', 'list'], {
      refetchType: 'active',
      refetchActive: true
    });
    queryClient.invalidateQueries(['orders', 'stats'], {
      refetchType: 'active',
      refetchActive: true
    });
    
    // V√©rifier si la commande contient des produits avec stock critique
    // et d√©clencher un rafra√Æchissement des notifications si n√©cessaire
    if (order.hasCriticalStock) {
      queryClient.invalidateQueries(['notifications', 'recent'], { 
        refetchType: 'active',
        refetchActive: true
      });
      queryClient.invalidateQueries(['notifications', 'unread-count'], { 
        refetchType: 'active',
        refetchActive: true
      });
    }
  };

  const handleOrderUpdated = (order: Order) => {
    showNotification(`Commande #${order.orderNumber} mise √† jour`, 'info');
    // Invalider les requ√™tes pour forcer un rechargement des donn√©es
    queryClient.invalidateQueries(['orders']);
    queryClient.invalidateQueries(['orders', 'list']);
    queryClient.invalidateQueries(['orders', 'detail', order.id]);
    queryClient.invalidateQueries(['orders', 'stats']);
  };

  const handleOrderStatus = ({ orderNumber, status, orderId }: { orderNumber: string; status: string; orderId?: string }) => {
    // Notification sp√©ciale pour les commandes confirm√©es avec num√©ro de r√©f√©rence
    if (status === 'CONFIRMED') {
      showNotification(`üéâ Commande #${orderNumber} confirm√©e avec succ√®s!`, 'success');
    } else {
      showNotification(`Statut de la commande #${orderNumber} chang√© √† ${status}`, 'info');
    }
    
    // Invalider les requ√™tes pour forcer un rechargement des donn√©es
    queryClient.invalidateQueries(['orders']);
    queryClient.invalidateQueries(['orders', 'list']);
    queryClient.invalidateQueries(['orders', 'stats']);
    
    // Si l'ID de la commande est disponible, invalider √©galement les d√©tails sp√©cifiques
    if (orderId) {
      queryClient.invalidateQueries(['orders', 'detail', orderId]);
    }
  };

  // Utilitaire pour convertir les niveaux de s√©v√©rit√© en types de notification
  const getSeverityType = (severity: string): 'success' | 'info' | 'warning' | 'error' => {
    switch (severity) {
      case 'CRITICAL':
        return 'error';
      case 'HIGH':
        return 'warning';
      case 'MEDIUM':
        return 'info';
      case 'LOW':
        return 'success';
      default:
        return 'info';
    }
  };

  useEffect(() => {
    const newSocket = setupSocket();

    return () => {
      if (newSocket) {
        newSocket.close();
      }
    };
  }, []);

  const reconnect = () => {
    if (socket) {
      socket.close();
    }
    setupSocket();
  };

  return (
    <SocketContext.Provider value={{ connected, reconnect }}>
      {children}
    </SocketContext.Provider>
  );
}; 